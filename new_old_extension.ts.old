import * as vscode from 'vscode';
import axios from 'axios';
import * as fs from 'fs';
import * as path from 'path';
import * as glob from 'glob';
import commandsJson from './src/copilot-automator-commands.json';

// --- Constants ---
const LOG_LEVEL_ERROR = 'ERROR';
const LOG_LEVEL_WARNING = 'WARNING';
const LOG_LEVEL_INFO = 'INFO';
const INSTRUCTIONS_FOLDER = 'instructions';
const MAX_FILE_SIZE = 1024 * 1024 * 2; // 2MB
let MAX_PROMPTS_PER_SESSION = 10; // Default max prompts per session
const URL_CACHE: { [url: string]: { content: string; timestamp: number } } = {};
const CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour
const PROMPT_DELAY_MS = 2000;

// --- State ---
let promptCount = 0;
let agentCooperationActive = false;
let agentCooperationPaused = false;
let agentCooperationGoal: string | undefined;
let agentCooperationLoop: NodeJS.Timeout | undefined;
let logFilePath: string;
let selectedFiles: string[] = [];
let LLM_API_URL = 'http://localhost:1234/v1/chat/completions';
let LLM_MODEL = 'your-model-name';
let LLM_TEMPERATURE = 0.7;
let CONTEXT_SOURCE = 'editor';
let FILE_REVIEW_PATHS = '';
let SPEC_RESOURCE_URLS = '';
let LLM_ENDPOINTS: { label: string; url: string }[] = [
    { label: 'Local LLM', url: 'http://localhost:1234/v1/chat/completions' },
    { label: 'OpenAI', url: 'https://api.openai.com/v1/chat/completions' },
    { label: 'Grok', url: 'https://grok.api.example.com/v1/chat/completions' }
];

// --- Prompt History ---
interface PromptHistoryEntry {
    prompt: string;
    response?: string;
    timestamp: string;
}
let promptHistory: PromptHistoryEntry[] = [];

function addPromptHistory(prompt: string, response?: string) {
    promptHistory.push({ prompt, response, timestamp: new Date().toISOString() });
    if (promptHistory.length > 100) promptHistory.shift();
}

function getPromptHistory(limit = 10): PromptHistoryEntry[] {
    return promptHistory.slice(-limit);
}

// --- Automation History / Logs Tree View ---
class HistoryItem {
    constructor(
        public readonly label: string,
        public readonly description?: string,
        public readonly command?: vscode.Command
    ) {}
}

class HistoryProvider implements vscode.TreeDataProvider<HistoryItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<HistoryItem | undefined | void> = new vscode.EventEmitter<HistoryItem | undefined | void>();
    readonly onDidChangeTreeData: vscode.Event<HistoryItem | undefined | void> = this._onDidChangeTreeData.event;
    private history: HistoryItem[] = [];
    private static readonly CONTROL_ITEMS = [
        new HistoryItem('▶️ Start Agent Cooperation', '', { command: 'copilot-automator.start', title: 'Start Agent Cooperation' }),
        new HistoryItem('⏸️ Pause Agent Cooperation', '', { command: 'copilot-automator.pause', title: 'Pause Agent Cooperation' }),
        new HistoryItem('▶️ Resume Agent Cooperation', '', { command: 'copilot-automator.resume', title: 'Resume Agent Cooperation' }),
        new HistoryItem('⏹️ Stop Agent Cooperation', '', { command: 'copilot-automator.stop', title: 'Stop Agent Cooperation' }),
        new HistoryItem('⚙️ Settings', '', { command: 'copilot-automator.openSettings', title: 'Open Settings' }),
        new HistoryItem('📜 Spec Resources', '', { command: 'copilot-automator.manageSpecResources', title: 'Manage Specification Resources' }),
        new HistoryItem('📝 Create Instruction Template', '', { command: 'copilot-automator.createTemplateInstruction', title: 'Create Instruction Template' }),
        new HistoryItem('✅ Validate Instructions', '', { command: 'copilot-automator.validateInstructions', title: 'Validate Instructions' }),
        new HistoryItem('🚀 Run Instruction File', '', { command: 'copilot-automator.runInstructionFile', title: 'Run Instruction File' }),
        new HistoryItem('📜 View Logs', '', { command: 'copilot-automator.openLogViewer', title: 'View Logs' })
    ];

    add(item: HistoryItem) {
        this.history.unshift(item);
        if (this.history.length > 50) this.history.pop();
        this._onDidChangeTreeData.fire();
    }

    getTreeItem(element: HistoryItem): vscode.TreeItem {
        const item = new vscode.TreeItem(element.label, vscode.TreeItemCollapsibleState.None);
        item.description = element.description;
        item.command = element.command;
        return item;
    }

    getChildren(): Thenable<HistoryItem[]> {
        return Promise.resolve([...HistoryProvider.CONTROL_ITEMS, ...this.history]);
    }
}

// --- Available Commands Tree View ---
class CommandsProvider implements vscode.TreeDataProvider<CommandItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<CommandItem | undefined | void> = new vscode.EventEmitter<CommandItem | undefined | void>();
    readonly onDidChangeTreeData: vscode.Event<CommandItem | undefined | void> = this._onDidChangeTreeData.event;
    private commands: CommandItem[] = [];

    constructor(commandsJson: any) {
        try {
            this.commands = (commandsJson?.commands || []).map((cmd: any) => new CommandItem(cmd.command, cmd.description));
        } catch (err: unknown) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            logInteraction(LOG_LEVEL_ERROR, 'COMMANDS_JSON_INVALID', `Failed to load commands JSON: ${errorMessage}`);
            vscode.window.showErrorMessage(`Failed to load commands JSON: ${errorMessage}`);
            this.commands = [];
        }
    }

    getTreeItem(element: CommandItem): vscode.TreeItem {
        const item = new vscode.TreeItem(element.label, vscode.TreeItemCollapsibleState.None);
        item.description = element.description;
        item.command = { command: 'copilot-automator.runCommand', title: 'Run Command', arguments: [element.label] };
        return item;
    }

    getChildren(): Thenable<CommandItem[]> {
        return Promise.resolve(this.commands);
    }
}

class CommandItem {
    constructor(
        public readonly label: string,
        public readonly description?: string
    ) {}
}

// --- LLM Models Tree View ---
class LLMModelsProvider implements vscode.TreeDataProvider<LLMModelItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<LLMModelItem | undefined | void> = new vscode.EventEmitter<LLMModelItem | undefined | void>();
    readonly onDidChangeTreeData: vscode.Event<LLMModelItem | undefined | void> = this._onDidChangeTreeData.event;
    private models: string[] = [];
    private selectedModel: string | undefined;

    constructor(private context: vscode.ExtensionContext) {
        this.selectedModel = context.globalState.get('llmModel', LLM_MODEL);
    }

    async selectModel(model: string) {
        this.selectedModel = model;
        await this.context.globalState.update('llmModel', model);
        LLM_MODEL = model;
        this._onDidChangeTreeData.fire();
        vscode.window.showInformationMessage(`Selected LLM model: ${model}`);
        logInteraction(LOG_LEVEL_INFO, 'LLM_MODEL_SELECTED', model);
    }

    async refresh() {
        try {
            const apiUrl = LLM_API_URL.replace(/\/v1\/chat\/completions$/, '/v1/models');
            const response = await axios.get(apiUrl, { timeout: 5000 });
            this.models = response.data.data?.map((m: any) => m.id) || [];
            logInteraction(LOG_LEVEL_INFO, 'LLM_MODELS_REFRESHED', `Fetched ${this.models.length} models`);
        } catch (err: unknown) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            this.models = [];
            logInteraction(LOG_LEVEL_ERROR, 'LLM_MODELS_FETCH_FAILED', errorMessage);
            vscode.window.showErrorMessage(`Failed to refresh LLM models: ${errorMessage}`);
        }
        this._onDidChangeTreeData.fire();
    }

    getTreeItem(element: LLMModelItem): vscode.TreeItem {
        const item = new vscode.TreeItem(element.label, vscode.TreeItemCollapsibleState.None);
        if (element.label === this.selectedModel) {
            item.description = 'Selected';
        }
        item.command = { command: 'copilot-automator.selectModel', title: 'Select Model', arguments: [element.label] };
        return item;
    }

    getChildren(): Thenable<LLMModelItem[]> {
        return Promise.resolve(this.models.map(m => new LLMModelItem(m)));
    }
}

class LLMModelItem {
    constructor(public readonly label: string) {}
}

// --- Instruction File Management ---
interface InstructionStep {
    action: string;
    prompt?: string;
    condition?: { type: string; value: any }; // For future conditional logic
    storeAs?: string;
    [key: string]: any;
}

async function runAutomationFromInstructionFile(historyProvider: HistoryProvider) {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    const instructionsDir = ensureInstructionsFolder(workspaceFolders);
    if (!instructionsDir) {
        vscode.window.showErrorMessage('No workspace folder found.');
        logInteraction(LOG_LEVEL_ERROR, 'NO_WORKSPACE', 'No workspace folder for instruction files.');
        return;
    }
    const files = fs.readdirSync(instructionsDir).filter(f => f.endsWith('.json'));
    if (files.length === 0) {
        vscode.window.showWarningMessage('No instruction files found.');
        logInteraction(LOG_LEVEL_WARNING, 'NO_INSTRUCTION_FILES', 'No JSON files in instructions folder.');
        return;
    }
    const fileName = await vscode.window.showQuickPick(files, { placeHolder: 'Select an instruction file to run' });
    if (!fileName) return;
    const filePath = path.join(instructionsDir, fileName);
    let steps: InstructionStep[] = [];
    try {
        const content = fs.readFileSync(filePath, 'utf-8');
        const parsed = JSON.parse(content);
        steps = parsed.steps;
        if (!Array.isArray(steps)) throw new Error('No steps array in file.');
    } catch (err: unknown) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        vscode.window.showErrorMessage(`Failed to parse instruction file: ${errorMessage}`);
        logInteraction(LOG_LEVEL_ERROR, 'INVALID_INSTRUCTION_FILE', `File ${filePath}: ${errorMessage}`);
        return;
    }
    const variables: { [key: string]: any } = {};
    for (const [i, step] of steps.entries()) {
        try {
            switch (step.action) {
                case 'sendPrompt':
                    if (!step.prompt) throw new Error('Missing prompt in step.');
                    let prompt = step.prompt;
                    for (const key in variables) {
                        prompt = prompt.replace(`{{${key}}}`, variables[key]);
                    }
                    await sendPromptToChat(prompt, historyProvider);
                    if (step.storeAs) {
                        variables[step.storeAs] = prompt;
                    }
                    break;
                case 'acceptSuggestion':
                    await acceptCopilotSuggestion();
                    break;
                default:
                    historyProvider.add(new HistoryItem('Unknown Step', `Step ${i + 1}: ${JSON.stringify(step)}`));
                    logInteraction(LOG_LEVEL_WARNING, 'UNKNOWN_STEP', step);
            }
        } catch (err: unknown) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            historyProvider.add(new HistoryItem('Step Failed', `Step ${i + 1}: ${errorMessage}`));
            logInteraction(LOG_LEVEL_ERROR, 'STEP_FAILED', { step, error: errorMessage });
            vscode.window.showErrorMessage(`Step ${i + 1} failed: ${errorMessage}`);
            break;
        }
    }
    vscode.window.showInformationMessage('Automation job complete.');
    logInteraction(LOG_LEVEL_INFO, 'INSTRUCTION_JOB_COMPLETED', `File: ${filePath}`);
}

async function validateAllInstructionFiles() {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    const instructionsDir = ensureInstructionsFolder(workspaceFolders);
    if (!instructionsDir) {
        vscode.window.showErrorMessage('No workspace folder found.');
        logInteraction(LOG_LEVEL_ERROR, 'NO_WORKSPACE', 'No workspace folder for validation.');
        return;
    }
    const files = fs.readdirSync(instructionsDir).filter(f => f.endsWith('.json'));
    let errors: string[] = [];
    let warnings: string[] = [];
    for (const file of files) {
        const filePath = path.join(instructionsDir, file);
        try {
            const content = fs.readFileSync(filePath, 'utf-8');
            const parsed = JSON.parse(content);
            if (!parsed.description || !Array.isArray(parsed.steps)) {
                warnings.push(`${file}: Missing 'description' or 'steps' array.`);
            }
        } catch (err: unknown) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            errors.push(`${file}: Invalid JSON (${errorMessage})`);
        }
    }
    let summary = '';
    if (errors.length === 0 && warnings.length === 0) {
        summary = 'All instruction files are valid.';
        vscode.window.showInformationMessage(summary);
    } else {
        if (errors.length > 0) summary += 'Errors:\n' + errors.join('\n') + '\n';
        if (warnings.length > 0) summary += 'Warnings:\n' + warnings.join('\n');
        vscode.window.showErrorMessage(summary, { modal: true });
    }
    logInteraction(LOG_LEVEL_INFO, 'INSTRUCTION_FILES_VALIDATED', { errors, warnings });
}

async function createTemplateInstructionFile() {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    const instructionsDir = ensureInstructionsFolder(workspaceFolders);
    if (!instructionsDir) {
        vscode.window.showErrorMessage('No workspace folder found.');
        logInteraction(LOG_LEVEL_ERROR, 'NO_WORKSPACE', 'No workspace folder for template creation.');
        return;
    }
    const defaultName = `instruction-${Date.now()}.json`;
    const fileName = await vscode.window.showInputBox({ prompt: 'Enter a name for the new instruction file', value: defaultName });
    if (!fileName) return;
    const filePath = path.join(instructionsDir, fileName.endsWith('.json') ? fileName : fileName + '.json');
    if (fs.existsSync(filePath)) {
        vscode.window.showWarningMessage('File already exists.');
        logInteraction(LOG_LEVEL_WARNING, 'TEMPLATE_FILE_EXISTS', `File: ${filePath}`);
        return;
    }
    const template = {
        description: 'Describe the automation goal or instruction.',
        steps: [
            { action: 'sendPrompt', prompt: 'Your prompt here.', storeAs: 'result' },
            { action: 'acceptSuggestion' }
        ]
    };
    try {
        fs.writeFileSync(filePath, JSON.stringify(template, null, 2));
        logInteraction(LOG_LEVEL_INFO, 'TEMPLATE_CREATED', `File: ${filePath}`);
        const doc = await vscode.workspace.openTextDocument(filePath);
        await vscode.window.showTextDocument(doc);
        vscode.window.showInformationMessage(`Template instruction file created: ${filePath}`);
    } catch (err: unknown) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        logInteraction(LOG_LEVEL_ERROR, 'TEMPLATE_CREATION_FAILED', `File: ${filePath}, Error: ${errorMessage}`);
        vscode.window.showErrorMessage(`Failed to create template: ${errorMessage}`);
    }
}

// --- Log Viewer Panel ---
function openLogViewerPanel() {
    const panel = vscode.window.createWebviewPanel(
        'copilotAutomatorLogViewer',
        'Copilot Automator Logs',
        vscode.ViewColumn.One,
        { enableScripts: true }
    );
    let logContent = '';
    try {
        logContent = fs.readFileSync(logFilePath, 'utf-8');
    } catch (err: unknown) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        logContent = `No log file found or failed to read log: ${errorMessage}`;
        logInteraction(LOG_LEVEL_ERROR, 'LOG_READ_FAILED', errorMessage);
    }
    panel.webview.html = getLogViewerHtml(logContent);
    panel.webview.onDidReceiveMessage((msg: any) => {
        if (msg.command === 'filterLogs') {
            let filtered = '';
            try {
                const lines = logContent.split('\n').filter(Boolean);
                filtered = lines
                    .filter(line => {
                        try {
                            const entry = JSON.parse(line);
                            return msg.level === 'ALL' || entry.logLevel === msg.level;
                        } catch {
                            return false;
                        }
                    })
                    .join('\n');
            } catch (err: unknown) {
                const errorMessage = err instanceof Error ? err.message : String(err);
                filtered = `Error filtering logs: ${errorMessage}`;
                logInteraction(LOG_LEVEL_ERROR, 'LOG_FILTER_FAILED', errorMessage);
            }
            panel.webview.postMessage({ command: 'showFiltered', content: filtered });
        }
    });
}

function getLogViewerHtml(logContent: string): string {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copilot Automator Logs</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 font-sans p-4">
    <h2 class="text-2xl font-bold mb-4 text-blue-700">Copilot Automator Logs</h2>
    <div class="mb-4">
        <label class="mr-2 font-semibold">Filter by Level:</label>
        <select id="logLevel" class="border rounded px-2 py-1">
            <option value="ALL">All</option>
            <option value="INFO">INFO</option>
            <option value="ERROR">ERROR</option>
            <option value="WARNING">WARNING</option>
        </select>
        <button id="filterBtn" class="ml-2 bg-blue-600 hover:bg-blue-700 text-white px-4 py-1 rounded">Filter</button>
    </div>
    <pre id="logContent" class="bg-white border border-gray-300 rounded p-2 h-96 overflow-y-auto text-xs">${logContent.replace(/</g, '&lt;')}</pre>
    <script>
        const vscode = acquireVsCodeApi();
        document.getElementById('filterBtn').onclick = () => {
            const level = document.getElementById('logLevel').value;
            vscode.postMessage({ command: 'filterLogs', level });
        };
        window.addEventListener('message', event => {
            if (event.data.command === 'showFiltered') {
                document.getElementById('logContent').textContent = event.data.content;
            }
        });
    </script>
</body>
</html>`;
}

// --- Settings Panel ---
function openSettingsPanel(context: vscode.ExtensionContext) {
    const panel = vscode.window.createWebviewPanel(
        'copilotAutomatorSettings',
        'Copilot Automator Settings',
        vscode.ViewColumn.One,
        { enableScripts: true }
    );
    const settings = {
        llmApiUrl: context.globalState.get('llmApiUrl', LLM_API_URL),
        llmModel: context.globalState.get('llmModel', LLM_MODEL),
        llmTemp: context.globalState.get('llmTemp', LLM_TEMPERATURE),
        maxPrompts: context.globalState.get('maxPrompts', MAX_PROMPTS_PER_SESSION),
        contextSource: context.globalState.get('contextSource', 'editor'),
        fileReviewPaths: context.globalState.get('fileReviewPaths', ''),
        specResourceUrls: context.globalState.get('specResourceUrls', ''),
        llmEndpoints: LLM_ENDPOINTS
    };
    panel.webview.html = getSettingsHtml(settings);
    panel.webview.onDidReceiveMessage(async (msg: any) => {
        if (msg.command === 'saveSettings') {
            await context.globalState.update('llmApiUrl', msg.llmApiUrl);
            await context.globalState.update('llmModel', msg.llmModel);
            await context.globalState.update('llmTemp', msg.llmTemp);
            await context.globalState.update('maxPrompts', msg.maxPrompts);
            await context.globalState.update('contextSource', msg.contextSource);
            await context.globalState.update('fileReviewPaths', msg.fileReviewPaths);
            await context.globalState.update('specResourceUrls', msg.specResourceUrls);
            LLM_API_URL = msg.llmApiUrl;
            LLM_MODEL = msg.llmModel;
            LLM_TEMPERATURE = msg.llmTemp;
            MAX_PROMPTS_PER_SESSION = msg.maxPrompts;
            CONTEXT_SOURCE = msg.contextSource;
            FILE_REVIEW_PATHS = msg.fileReviewPaths;
            SPEC_RESOURCE_URLS = msg.specResourceUrls;
            vscode.window.showInformationMessage('Copilot Automator settings saved.');
            logInteraction(LOG_LEVEL_INFO, 'SETTINGS_SAVED', msg);
        } else if (msg.command === 'selectLlmEndpoint') {
            LLM_API_URL = msg.url;
            await context.globalState.update('llmApiUrl', msg.url);
            vscode.window.showInformationMessage(`Selected LLM endpoint: ${msg.url}`);
            logInteraction(LOG_LEVEL_INFO, 'LLM_ENDPOINT_SELECTED', msg.url);
        }
    });
}

function getSettingsHtml(settings: {
    llmApiUrl: string;
    llmModel: string;
    llmTemp: number;
    maxPrompts: number;
    contextSource: string;
    fileReviewPaths: string;
    specResourceUrls: string;
    llmEndpoints: { label: string; url: string }[];
}): string {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copilot Automator Settings</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 font-sans p-4">
    <h2 class="text-2xl font-bold mb-4 text-blue-700">Copilot Automator Settings</h2>
    <form onsubmit="event.preventDefault(); saveSettings();" class="space-y-4">
        <div>
            <label class="block font-semibold">LLM Endpoint</label>
            <select id="llmEndpoint" class="w-full border rounded px-2 py-1">
                ${settings.llmEndpoints.map(e => `<option value="${e.url}" ${e.url === settings.llmApiUrl ? 'selected' : ''}>${e.label}</option>`).join('')}
            </select>
            <button type="button" onclick="selectLlmEndpoint()" class="mt-2 bg-blue-600 hover:bg-blue-700 text-white px-4 py-1 rounded">Set Endpoint</button>
        </div>
        <div>
            <label class="block font-semibold">LLM API URL</label>
            <input type="text" id="llmApiUrl" value="${settings.llmApiUrl}" class="w-full border rounded px-2 py-1" />
        </div>
        <div>
            <label class="block font-semibold">Model</label>
            <input type="text" id="llmModel" value="${settings.llmModel}" class="w-full border rounded px-2 py-1" />
        </div>
        <div>
            <label class="block font-semibold">Temperature</label>
            <input type="number" id="llmTemp" value="${settings.llmTemp}" step="0.01" min="0" max="2" class="w-full border rounded px-2 py-1" />
        </div>
        <div>
            <label class="block font-semibold">Max Prompts/Session</label>
            <input type="number" id="maxPrompts" value="${settings.maxPrompts}" min="1" max="100" class="w-full border rounded px-2 py-1" />
        </div>
        <div>
            <label class="block font-semibold">Context Source</label>
            <select id="contextSource" class="w-full border rounded px-2 py-1">
                <option value="editor" ${settings.contextSource === 'editor' ? 'selected' : ''}>Active Editor</option>
                <option value="chat" ${settings.contextSource === 'chat' ? 'selected' : ''}>Copilot Chat (if available)</option>
            </select>
        </div>
        <div>
            <label class="block font-semibold">File Review Paths (e.g., src/*.ts)</label>
            <input type="text" id="fileReviewPaths" value="${settings.fileReviewPaths}" placeholder="Comma-separated paths or patterns" class="w-full border rounded px-2 py-1" />
        </div>
        <div>
            <label class="block font-semibold">Specification Resource URLs (comma-separated)</label>
            <input type="text" id="specResourceUrls" value="${settings.specResourceUrls}" placeholder="e.g., https://example.com/spec" class="w-full border rounded px-2 py-1" />
        </div>
        <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">Save</button>
    </form>
    <script>
        const vscode = acquireVsCodeApi();
        function saveSettings() {
            vscode.postMessage({
                command: 'saveSettings',
                llmApiUrl: document.getElementById('llmApiUrl').value,
                llmModel: document.getElementById('llmModel').value,
                llmTemp: parseFloat(document.getElementById('llmTemp').value),
                maxPrompts: parseInt(document.getElementById('maxPrompts').value, 10),
                contextSource: document.getElementById('contextSource').value,
                fileReviewPaths: document.getElementById('fileReviewPaths').value,
                specResourceUrls: document.getElementById('specResourceUrls').value
            });
        }
        function selectLlmEndpoint() {
            const url = document.getElementById('llmEndpoint').value;
            vscode.postMessage({ command: 'selectLlmEndpoint', url });
            document.getElementById('llmApiUrl').value = url;
        }
    </script>
</body>
</html>`;
}

// --- Specification Resources Panel ---
function openSpecResourcesPanel(context: vscode.ExtensionContext) {
    const panel = vscode.window.createWebviewPanel(
        'copilotAutomatorSpecResources',
        'Specification Resources',
        vscode.ViewColumn.One,
        { enableScripts: true }
    );
    const specResourceUrls = context.globalState.get<string>('specResourceUrls', '');
    const urls = specResourceUrls ? specResourceUrls.split(',').map((url: string) => url.trim()) : [];
    panel.webview.html = getSpecResourcesHtml(urls);
    panel.webview.onDidReceiveMessage(async (msg) => {
        if (msg.command === 'saveSpecUrls') {
            const newUrls = msg.urls.join(',');
            await context.globalState.update('specResourceUrls', newUrls);
            SPEC_RESOURCE_URLS = newUrls;
            vscode.window.showInformationMessage('Specification resource URLs saved.');
            logInteraction(LOG_LEVEL_INFO, 'SPEC_URLS_SAVED', newUrls);
        }
    });
}

function getSpecResourcesHtml(urls: string[]): string {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Specification Resources</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 font-sans p-4">
    <h2 class="text-2xl font-bold mb-4 text-blue-700">Specification Resources</h2>
    <ul id="urlList" class="space-y-2">
        ${urls.map((url, index) => `
            <li class="flex items-center">
                <input type="text" value="${url}" data-index="${index}" class="flex-1 border rounded px-2 py-1 mr-2" />
                <button onclick="removeUrl(${index})" class="bg-red-600 hover:bg-red-700 text-white px-2 py-1 rounded">Remove</button>
            </li>
        `).join('')}
    </ul>
    <button id="addUrl" class="mt-4 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded">Add URL</button>
    <button onclick="saveUrls()" class="mt-2 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">Save</button>
    <script>
        const vscode = acquireVsCodeApi();
        const urlList = document.getElementById('urlList');
        document.getElementById('addUrl').onclick = () => {
            const li = document.createElement('li');
            li.className = 'flex items-center';
            li.innerHTML = '<input type="text" placeholder="Enter URL" data-index="' + urlList.children.length + '" class="flex-1 border rounded px-2 py-1 mr-2" /><button onclick="removeUrl(' + urlList.children.length + ')" class="bg-red-600 hover:bg-red-700 text-white px-2 py-1 rounded">Remove</button>';
            urlList.appendChild(li);
        };
        function removeUrl(index) {
            const li = urlList.querySelector('[data-index="' + index + '"]').parentElement;
            urlList.removeChild(li);
            Array.from(urlList.children).forEach((child, i) => {
                child.querySelector('input').setAttribute('data-index', i);
                child.querySelector('button').setAttribute('onclick', 'removeUrl(' + i + ')');
            });
        }
        function saveUrls() {
            const urls = Array.from(urlList.querySelectorAll('input')).map(input => input.value.trim()).filter(url => url);
            vscode.postMessage({ command: 'saveSpecUrls', urls });
        }
    </script>
</body>
</html>`;
}

// --- Flexible File Selection ---
async function flexibleFileSelection() {
    const options = ['Multi-select files', 'Enter glob pattern', 'Manual file path entry'];
    const choice = await vscode.window.showQuickPick(options, { placeHolder: 'How would you like to select files for LLM review?' });
    if (!choice) return;
    let files: string[] = [];
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) {
        vscode.window.showErrorMessage('No workspace folder open.');
        logInteraction(LOG_LEVEL_ERROR, 'NO_WORKSPACE', 'No workspace for file selection.');
        return;
    }
    const root = workspaceFolders[0].uri.fsPath;
    if (choice === 'Multi-select files') {
        const uris = await vscode.window.showOpenDialog({ canSelectFiles: true, canSelectFolders: false, canSelectMany: true, openLabel: 'Select Files for LLM Review' });
        if (uris && uris.length > 0) {
            files = uris.map(u => u.fsPath);
        }
    } else if (choice === 'Enter glob pattern') {
        const pattern = await vscode.window.showInputBox({ prompt: 'Enter a glob pattern (e.g., src/**/*.ts)' });
        if (pattern) {
            try {
                files = glob.sync(pattern, { cwd: root, absolute: true });
            } catch (err: unknown) {
                const errorMessage = err instanceof Error ? err.message : String(err);
                vscode.window.showErrorMessage(`Invalid glob pattern: ${errorMessage}`);
                logInteraction(LOG_LEVEL_ERROR, 'INVALID_GLOB_PATTERN', errorMessage);
            }
        }
    } else if (choice === 'Manual file path entry') {
        const input = await vscode.window.showInputBox({ prompt: 'Enter file paths, comma-separated' });
        if (input) {
            files = input.split(',').map(f => path.resolve(root, f.trim())).filter(f => fs.existsSync(f));
        }
    }
    if (files.length > 0) {
        selectedFiles = files.filter(f => f.startsWith(root));
        const fileNames = selectedFiles.map(f => path.basename(f)).join(', ');
        logInteraction(LOG_LEVEL_INFO, 'FLEXIBLE_FILES_SELECTED', `Selected files: ${fileNames}`);
        vscode.window.showInformationMessage(`Selected ${selectedFiles.length} file(s) for LLM review.`);
    } else {
        vscode.window.showWarningMessage('No files selected.');
        logInteraction(LOG_LEVEL_WARNING, 'FILES_SELECTION_CANCELLED', 'No files selected.');
    }
}

// --- Logging ---
function logInteraction(logLevel: string, action: string, message: any) {
    const entry = {
        timestamp: new Date().toISOString(),
        logLevel,
        action,
        message
    };
    try {
        fs.appendFileSync(logFilePath, JSON.stringify(entry) + '\n');
    } catch (err: unknown) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        console.error('Failed to write log:', errorMessage);
        vscode.window.showErrorMessage(`Failed to write to log file: ${errorMessage}`);
    }
}

// --- Create Instructions Folder ---
function ensureInstructionsFolder(workspaceFolders: readonly vscode.WorkspaceFolder[] | undefined): string | undefined {
    if (!workspaceFolders || workspaceFolders.length === 0) {
        logInteraction(LOG_LEVEL_WARNING, 'NO_WORKSPACE', 'No workspace folders found for instructions folder creation.');
        vscode.window.showWarningMessage('No workspace open. Cannot create instructions folder.');
        return undefined;
    }
    const root = workspaceFolders[0].uri.fsPath;
    const instructionsDir = path.join(root, INSTRUCTIONS_FOLDER);
    try {
        if (!fs.existsSync(instructionsDir)) {
            fs.mkdirSync(instructionsDir, { recursive: true });
            logInteraction(LOG_LEVEL_INFO, 'INSTRUCTIONS_FOLDER_CREATED', `Created instructions folder at ${instructionsDir}`);
            vscode.window.showInformationMessage(`Created instructions folder at ${instructionsDir}`);
        }
    } catch (err: unknown) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        logInteraction(LOG_LEVEL_ERROR, 'INSTRUCTIONS_FOLDER_CREATION_FAILED', errorMessage);
        vscode.window.showErrorMessage(`Failed to create instructions folder: ${errorMessage}`);
        return undefined;
    }
    return instructionsDir;
}

// --- File and Instructions Retrieval for LLM Review ---
async function getFilesForLLMReview(): Promise<string> {
    let fileContents = '';
    const patterns = FILE_REVIEW_PATHS ? FILE_REVIEW_PATHS.split(',').map(p => p.trim()) : [];
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) return 'No workspace folder open.';

    const instructionsDir = ensureInstructionsFolder(workspaceFolders);
    if (instructionsDir) patterns.push(path.join(INSTRUCTIONS_FOLDER, '*.json'));

    if (selectedFiles.length > 0) {
        for (const filePath of selectedFiles) {
            if (!filePath.startsWith(workspaceFolders[0].uri.fsPath)) {
                logInteraction(LOG_LEVEL_WARNING, 'FILE_ACCESS_DENIED', `File ${filePath} is outside workspace.`);
                vscode.window.showWarningMessage(`File ${path.basename(filePath)} is outside workspace and will be skipped.`);
                continue;
            }
            try {
                const stats = fs.statSync(filePath);
                let content = '';
                if (stats.size > MAX_FILE_SIZE) {
                    const fd = fs.openSync(filePath, 'r');
                    const buffer = Buffer.alloc(MAX_FILE_SIZE);
                    fs.readSync(fd, buffer, 0, MAX_FILE_SIZE, 0);
                    fs.closeSync(fd);
                    content = buffer.toString('utf-8') + '\n[Truncated: file too large]';
                    logInteraction(LOG_LEVEL_WARNING, 'FILE_TRUNCATED', `File truncated: ${filePath}`);
                } else {
                    content = fs.readFileSync(filePath, 'utf-8');
                }
                if (filePath.startsWith(path.join(workspaceFolders[0].uri.fsPath, INSTRUCTIONS_FOLDER)) && filePath.endsWith('.json')) {
                    try {
                        JSON.parse(content);
                    } catch (err: unknown) {
                        const errorMessage = err instanceof Error ? err.message : String(err);
                        logInteraction(LOG_LEVEL_ERROR, 'INVALID_JSON', `Invalid JSON in ${filePath}: ${errorMessage}`);
                        vscode.window.showErrorMessage(`Invalid JSON in ${path.basename(filePath)}: ${errorMessage}`);
                        continue;
                    }
                }
                fileContents += `\n\nFile: ${filePath}\n${content}`;
                logInteraction(LOG_LEVEL_INFO, 'FILE_REVIEW', `Read file: ${filePath}`);
            } catch (err: unknown) {
                const errorMessage = err instanceof Error ? err.message : String(err);
                logInteraction(LOG_LEVEL_ERROR, 'FILE_READ_FAILED', `Failed to read file ${filePath}: ${errorMessage}`);
                vscode.window.showErrorMessage(`Failed to read file ${path.basename(filePath)}: ${errorMessage}`);
            }
        }
    }

    if (patterns.length > 0 && workspaceFolders) {
        const root = workspaceFolders[0].uri.fsPath;
        for (const pattern of patterns) {
            try {
                const files = glob.sync(pattern, { cwd: root, absolute: true });
                for (const filePath of files) {
                    if (!filePath.startsWith(root)) {
                        logInteraction(LOG_LEVEL_WARNING, 'FILE_ACCESS_DENIED', `File ${filePath} is outside workspace.`);
                        vscode.window.showWarningMessage(`File ${path.basename(filePath)} is outside workspace and will be skipped.`);
                        continue;
                    }
                    try {
                        const stats = fs.statSync(filePath);
                        let content = '';
                        if (stats.size > MAX_FILE_SIZE) {
                            const fd = fs.openSync(filePath, 'r');
                            const buffer = Buffer.alloc(MAX_FILE_SIZE);
                            fs.readSync(fd, buffer, 0, MAX_FILE_SIZE, 0);
                            fs.closeSync(fd);
                            content = buffer.toString('utf-8') + '\n[Truncated: file too large]';
                            logInteraction(LOG_LEVEL_WARNING, 'FILE_TRUNCATED', `File truncated: ${filePath}`);
                        } else {
                            content = fs.readFileSync(filePath, 'utf-8');
                        }
                        if (filePath.startsWith(path.join(root, INSTRUCTIONS_FOLDER)) && filePath.endsWith('.json')) {
                            try {
                                JSON.parse(content);
                            } catch (err: unknown) {
                                const errorMessage = err instanceof Error ? err.message : String(err);
                                logInteraction(LOG_LEVEL_ERROR, 'INVALID_JSON', `Invalid JSON in ${filePath}: ${errorMessage}`);
                                vscode.window.showErrorMessage(`Invalid JSON in ${path.basename(filePath)}: ${errorMessage}`);
                                continue;
                            }
                        }
                        fileContents += `\n\nFile: ${filePath}\n${content}`;
                        logInteraction(LOG_LEVEL_INFO, 'FILE_REVIEW', `Read file: ${filePath}`);
                    } catch (err: unknown) {
                        const errorMessage = err instanceof Error ? err.message : String(err);
                        logInteraction(LOG_LEVEL_ERROR, 'FILE_READ_FAILED', `Failed to read file ${filePath}: ${errorMessage}`);
                        vscode.window.showErrorMessage(`Failed to read file ${path.basename(filePath)}: ${errorMessage}`);
                    }
                }
            } catch (err: unknown) {
                const errorMessage = err instanceof Error ? err.message : String(err);
                logInteraction(LOG_LEVEL_ERROR, 'PATTERN_PROCESSING_FAILED', `Failed to process pattern ${pattern}: ${errorMessage}`);
                vscode.window.showErrorMessage(`Failed to process file pattern ${pattern}: ${errorMessage}`);
            }
        }
    }

    if (!fileContents) {
        logInteraction(LOG_LEVEL_INFO, 'NO_FILES_REVIEWED', 'No files selected or matched for LLM review.');
        vscode.window.showInformationMessage('No files available for LLM review.');
    }
    return fileContents || 'No file content available for review.';
}

// --- Fetch Specification Resources ---
async function fetchSpecResources(): Promise<string> {
    let specContent = '';
    const urls = SPEC_RESOURCE_URLS ? SPEC_RESOURCE_URLS.split(',').map(url => url.trim()).filter(url => url) : [];
    for (const url of urls) {
        try {
            new URL(url);
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                throw new Error('Invalid protocol');
            }
        } catch (err: unknown) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            logInteraction(LOG_LEVEL_ERROR, 'INVALID_URL', `Invalid URL ${url}: ${errorMessage}`);
            vscode.window.showErrorMessage(`Invalid URL ${url}: ${errorMessage}`);
            continue;
        }
        if (URL_CACHE[url] && Date.now() - URL_CACHE[url].timestamp < CACHE_TTL_MS) {
            specContent += `\n\nSpecification Resource (Cached): ${url}\n${URL_CACHE[url].content}`;
            logInteraction(LOG_LEVEL_INFO, 'SPEC_RESOURCE_CACHED', `Used cached content for ${url}`);
            continue;
        }
        try {
            const response = await axios.get(url, { timeout: 5000 });
            let data = response.data;
            if (typeof data === 'string' && data.length > MAX_FILE_SIZE) {
                data = data.slice(0, MAX_FILE_SIZE) + '\n[Truncated: resource too large]';
                logInteraction(LOG_LEVEL_WARNING, 'SPEC_RESOURCE_TRUNCATED', `Resource truncated: ${url}`);
            }
            specContent += `\n\nSpecification Resource: ${url}\n${data}`;
            URL_CACHE[url] = { content: data, timestamp: Date.now() };
            logInteraction(LOG_LEVEL_INFO, 'SPEC_RESOURCE_FETCHED', `Fetched content from ${url}`);
        } catch (err: unknown) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            logInteraction(LOG_LEVEL_ERROR, 'SPEC_RESOURCE_FETCH_FAILED', `Failed to fetch ${url}: ${errorMessage}`);
            vscode.window.showErrorMessage(`Failed to fetch specification resource ${url}: ${errorMessage}`);
        }
    }
    if (!specContent) {
        logInteraction(LOG_LEVEL_INFO, 'NO_SPEC_RESOURCES', 'No specification resources available.');
        vscode.window.showInformationMessage('No specification resources available.');
    }
    return specContent || 'No specification resource content available.';
}

// --- LLM Integration ---
async function generatePromptFromLocalLLM(contextualInfo: string, fileContents: string, specContents: string, isRetry: boolean = false): Promise<string> {
    try {
        const history = getPromptHistory(5);
        const historyContext = history.length > 0 ? `\n\nRecent Prompt History:\n${history.map(h => `Prompt: ${h.prompt}\nResponse: ${h.response || 'None'}`).join('\n')}` : '';
        const payload = {
            model: LLM_MODEL,
            messages: [
                {
                    role: 'system',
                    content: `You are an expert coding assistant. When generating the next prompt for Copilot, enclose it strictly in <copilot_instructions> and </copilot_instructions> tags. Any other thoughts, explanations, or additional content should be outside these tags. If an error occurs, consult the specification resources: ${SPEC_RESOURCE_URLS}.`
                },
                {
                    role: 'user',
                    content: `${contextualInfo}\n\nFiles for review:\n${fileContents}\n\nSpecification Resources:\n${specContents}${historyContext}${isRetry ? '\n\nPrevious attempt failed. Review specifications and try again.' : ''}`
                }
            ],
            temperature: LLM_TEMPERATURE
        };
        const response = await axios.post(LLM_API_URL, payload);
        let content = response.data.choices?.[0]?.message?.content || '';
        logInteraction(LOG_LEVEL_INFO, 'LOCAL_LLM_REQUEST', { request: payload, response: content });
        const match = content.match(/<copilot_instructions>([\s\S]*?)<\/copilot_instructions>/);
        if (match && match[1]) {
            content = match[1].trim();
            logInteraction(LOG_LEVEL_INFO, 'PROMPT_EXTRACTED', content);
        } else {
            logInteraction(LOG_LEVEL_WARNING, 'NO_INSTRUCTIONS_TAG', 'No <copilot_instructions> tag found, using full content.');
            vscode.window.showWarningMessage('No <copilot_instructions> tags found in LLM response.');
        }
        addPromptHistory(contextualInfo, content);
        return content;
    } catch (err: unknown) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        logInteraction(LOG_LEVEL_ERROR, 'LOCAL_LLM_REQUEST', errorMessage);
        vscode.window.showErrorMessage(`LLM request failed: ${errorMessage}`);
        return '';
    }
}

// --- Copilot Chat Automation ---
async function sendPromptToChat(promptText: string, historyProvider: HistoryProvider) {
    if (!promptText) {
        logInteraction(LOG_LEVEL_ERROR, 'INVALID_PROMPT', 'Empty prompt provided.');
        vscode.window.showErrorMessage('Cannot send empty prompt to Copilot.');
        return;
    }
    const approval = await vscode.window.showQuickPick(['Yes', 'No'], {
        placeHolder: `Approve sending this prompt to Copilot? "${promptText.substring(0, 50)}${promptText.length > 50 ? '...' : ''}"`
    });
    if (approval !== 'Yes') {
        logInteraction(LOG_LEVEL_INFO, 'PROMPT_DENIED', promptText);
        historyProvider.add(new HistoryItem('Prompt Denied', promptText.substring(0, 50)));
        vscode.window.showInformationMessage('Prompt denied by user.');
        return;
    }
    if (promptText.toLowerCase().includes('run')) {
        const runApproval = await vscode.window.showQuickPick(['Yes', 'No'], {
            placeHolder: `This prompt includes a potential run request. Proceed? "${promptText.substring(0, 50)}${promptText.length > 50 ? '...' : ''}"`
        });
        if (runApproval !== 'Yes') {
            logInteraction(LOG_LEVEL_INFO, 'RUN_REQUEST_DENIED', promptText);
            historyProvider.add(new HistoryItem('Run Request Denied', promptText.substring(0, 50)));
            vscode.window.showInformationMessage('Run request denied by user.');
            return;
        }
    }
    if (promptCount >= MAX_PROMPTS_PER_SESSION) {
        try {
            await vscode.commands.executeCommand('workbench.action.closePanel');
            promptCount = 0;
            logInteraction(LOG_LEVEL_INFO, 'CHAT_SESSION_RESET', 'Session reset after max prompts.');
            vscode.window.showInformationMessage('Chat session reset.');
        } catch (err: unknown) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            logInteraction(LOG_LEVEL_ERROR, 'SESSION_RESET_FAILED', errorMessage);
            vscode.window.showErrorMessage(`Failed to reset chat session: ${errorMessage}`);
        }
    }
    try {
        await vscode.commands.executeCommand('workbench.action.chat.open', promptText);
        promptCount++;
        logInteraction(LOG_LEVEL_INFO, 'PROMPT_SENT', promptText);
        historyProvider.add(new HistoryItem('Prompt Sent', promptText.substring(0, 50)));
        vscode.window.showInformationMessage('Prompt sent to Copilot.');
    } catch (err: unknown) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        logInteraction(LOG_LEVEL_ERROR, 'PROMPT_SEND_FAILED', errorMessage);
        vscode.window.showErrorMessage(`Failed to send prompt: ${errorMessage}`);
    }
}

// --- Accept Copilot Suggestion ---
async function acceptCopilotSuggestion() {
    await new Promise(resolve => setTimeout(resolve, PROMPT_DELAY_MS));
    try {
        await vscode.commands.executeCommand('editor.action.inlineSuggest.commit');
        logInteraction(LOG_LEVEL_INFO, 'SUGGESTION_ACCEPTED', 'Accepted inline suggestion.');
        vscode.window.showInformationMessage('Accepted Copilot suggestion.');
    } catch (err: unknown) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        logInteraction(LOG_LEVEL_ERROR, 'SUGGESTION_ACCEPT_FAILED', errorMessage);
        vscode.window.showErrorMessage(`Failed to accept suggestion: ${errorMessage}`);
    }
}

// --- Read Context for Agent Cooperation ---
async function getLastCopilotChatResponse(): Promise<string> {
    if (CONTEXT_SOURCE === 'chat') {
        const last = getPromptHistory(1)[0];
        if (last && last.response) {
            logInteraction(LOG_LEVEL_INFO, 'CONTEXT_SOURCE', 'Using prompt history for chat context.');
            return last.response;
        }
        logInteraction(LOG_LEVEL_INFO, 'CONTEXT_SOURCE', 'Chat context not supported, falling back to editor.');
        vscode.window.showInformationMessage('Copilot chat context not supported, using editor context.');
        return 'Copilot chat response not available.';
    }
    const editor = vscode.window.activeTextEditor;
    if (editor) {
        const document = editor.document;
        const selection = editor.selection;
        const selectedText = document.getText(selection);
        const context = selectedText || document.getText();
        logInteraction(LOG_LEVEL_INFO, 'CONTEXT_SOURCE', 'Using editor context.');
        return context || 'No content in active editor.';
    }
    logInteraction(LOG_LEVEL_WARNING, 'CONTEXT_SOURCE', 'No active editor found.');
    vscode.window.showWarningMessage('No active editor found for context.');
    return 'No active editor context available.';
}

// --- Main Agent Cooperation ---
async function agentCooperationMain(goal: string, historyProvider: HistoryProvider) {
    while (agentCooperationActive) {
        if (agentCooperationPaused) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            continue;
        }
        const lastResponse = await getLastCopilotChatResponse();
        const fileContents = await getFilesForLLMReview();
        const specContents = await fetchSpecResources();
        if (lastResponse.includes('No active editor') || lastResponse.includes('not available')) {
            historyProvider.add(new HistoryItem('Warning', 'No editor context available for prompt generation.'));
        }
        if (fileContents === 'No file content available for review.') {
            historyProvider.add(new HistoryItem('Warning', 'No files selected or matched for LLM review.'));
        }
        if (specContents === 'No specification resource content available.') {
            historyProvider.add(new HistoryItem('Warning', 'No specification resources available.'));
        }
        const contextualInfo = lastResponse.includes('No active editor') || lastResponse.includes('not available')
            ? `Current goal: ${goal}. No prior response available.`
            : `Prior response: ${lastResponse}. Goal: ${goal}.`;
        let nextPrompt = await generatePromptFromLocalLLM(contextualInfo, fileContents, specContents);
        if (!nextPrompt) {
            historyProvider.add(new HistoryItem('Warning', 'Failed to generate prompt, retrying with specifications.'));
            nextPrompt = await generatePromptFromLocalLLM(contextualInfo, fileContents, specContents, true);
        }
        if (nextPrompt) {
            await sendPromptToChat(nextPrompt, historyProvider);
            await acceptCopilotSuggestion();
        } else {
            historyProvider.add(new HistoryItem('Error', 'Failed to generate next prompt.'));
            logInteraction(LOG_LEVEL_ERROR, 'PROMPT_GENERATION_FAILED', 'No prompt returned from LLM.');
            vscode.window.showErrorMessage('Failed to generate next prompt.');
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
}

// --- Automation File Discovery ---
// (Removed unused function findAutomationFile)

// --- Activity Bar View Provider ---
class AutomatorPanelProvider implements vscode.WebviewViewProvider {
    public static readonly viewType = 'copilotAutomatorPanel';

    constructor(private readonly _extensionUri: vscode.Uri) {}

    resolveWebviewView(webviewView: vscode.WebviewView, _context: vscode.WebviewViewResolveContext, _token: vscode.CancellationToken) {
        webviewView.webview.options = { enableScripts: true, localResourceRoots: [this._extensionUri] };
        webviewView.webview.html = this.getHtmlForWebview();
    }

    private getHtmlForWebview(): string {
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copilot Automator</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 font-sans p-4">
    <header class="flex items-center mb-4">
        <img src="https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f916.svg" alt="Robot Icon" class="w-8 h-8 mr-2" />
        <h2 class="text-2xl font-bold text-blue-700">Copilot Automator</h2>
    </header>
    <section aria-label="Automation Controls" class="mb-4">
        <h3 class="text-lg font-semibold mb-2 flex items-center"><span class="mr-2">⚡</span>Quick Actions</h3>
        <div id="controls" class="flex flex-wrap gap-2">
            <button id="goBtn" title="Start agent cooperation" aria-label="Go" class="transition bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded shadow focus Outline-none focus:ring-2 focus:ring-green-400 flex items-center"><span class="mr-1">▶️</span>Go</button>
            <button id="pauseBtn" title="Pause agent cooperation" aria-label="Pause" class="transition bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded shadow focus:outline-none focus:ring-2 focus:ring-orange-400 flex items-center"><span class="mr-1">⏸️</span>Pause</button>
            <button id="resumeBtn" title="Resume agent cooperation" aria-label="Resume" class="transition bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded shadow focus:outline-none focus:ring-2 focus:ring-green-400 flex items-center"><span class="mr-1">▶️</span>Resume</button>
            <button id="stopBtn" title="Stop agent cooperation" aria-label="Stop" class="transition bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded shadow focus:outline-none focus:ring-2 focus:ring-red-400 flex items-center"><span class="mr-1">⏹️</span>Stop</button>
            <button id="settingsBtn" title="Open settings panel" aria-label="Settings" class="transition bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded shadow focus:outline-none focus:ring-2 focus:ring-blue-400 flex items-center"><span class="mr-1">⚙️</span>Settings</button>
            <button id="selectFilesBtn" title="Select files for LLM review" aria-label="Select Files" class="transition bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded shadow focus:outline-none focus:ring-2 focus:ring-yellow-400 flex items-center"><span class="mr-1">📂</span>Select Files</button>
            <button id="specResourcesBtn" title="Manage specification resource URLs" aria-label="Spec Resources" class="transition bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded shadow focus:outline-none focus:ring-2 focus:ring-purple-400 flex items-center"><span class="mr-1">📜</span>Spec Resources</button>
            <button id="runInstructionBtn" title="Run instruction file" aria-label="Run Instruction" class="transition bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded shadow focus:outline-none focus:ring-2 focus:ring-indigo-400 flex items-center"><span class="mr-1">🚀</span>Run Instruction</button>
            <button id="logViewerBtn" title="View logs" aria-label="View Logs" class="transition bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded shadow focus:outline-none focus:ring-2 focus:ring-gray-400 flex items-center"><span class="mr-1">📜</span>View Logs</button>
        </div>
    </section>
    <section aria-label="Dialogue Log" class="mb-4">
        <h3 class="text-lg font-semibold mb-2 flex items-center"><span class="mr-2">💬</span>Dialogue</h3>
        <div id="dialogue" class="border border-gray-300 bg-white p-2 h-40 overflow-y-auto rounded mb-4 shadow-inner" aria-live="polite"></div>
    </section>
    <section aria-label="Send Command">
        <h3 class="text-lg font-semibold mb-2 flex items-center"><span class="mr-2">⌨️</span>Send Command</h3>
        <form id="commandForm" class="flex gap-2">
            <input type="text" id="commandInput" placeholder="Type a command (e.g., sendPrompt)" aria-label="Command Input" class="flex-1 border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-400" />
            <button type="submit" title="Send command to LLM or agent" aria-label="Send" class="transition bg-blue-600 hover:bg-blue-700 text-white px-4 py-1 rounded shadow focus:outline-none focus:ring-2 focus:ring-blue-400 flex items-center"><span class="mr-1">📤</span>Send</button>
        </form>
    </section>
    <script>
        const vscode = acquireVsCodeApi();
        const dialogue = document.getElementById('dialogue');
        document.getElementById('goBtn').onclick = () => {
            vscode.postMessage({ command: 'start' });
            addDialogue('User: Go');
        };
        document.getElementById('pauseBtn').onclick = () => {
            vscode.postMessage({ command: 'pause' });
            addDialogue('User: Pause');
        };
        document.getElementById('resumeBtn').onclick = () => {
            vscode.postMessage({ command: 'resume' });
            addDialogue('User: Resume');
        };
        document.getElementById('stopBtn').onclick = () => {
            vscode.postMessage({ command: 'stop' });
            addDialogue('User: Stop');
        };
        document.getElementById('settingsBtn').onclick = () => {
            vscode.postMessage({ command: 'openSettings' });
            addDialogue('User: Open Settings');
        };
        document.getElementById('selectFilesBtn').onclick = () => {
            vscode.postMessage({ command: 'selectFiles' });
            addDialogue('User: Select Files for Review');
        };
        document.getElementById('specResourcesBtn').onclick = () => {
            vscode.postMessage({ command: 'manageSpecResources' });
            addDialogue('User: Manage Specification Resources');
        };
        document.getElementById('runInstructionBtn').onclick = () => {
            vscode.postMessage({ command: 'runInstructionFile' });
            addDialogue('User: Run Instruction File');
        };
        document.getElementById('logViewerBtn').onclick = () => {
            vscode.postMessage({ command: 'openLogViewer' });
            addDialogue('User: View Logs');
        };
        document.getElementById('commandForm').onsubmit = (e) => {
            e.preventDefault();
            const cmd = document.getElementById('commandInput').value;
            if (cmd) {
                vscode.postMessage({ command: 'sendCommand', value: cmd });
                addDialogue('User: ' + cmd);
                document.getElementById('commandInput').value = '';
            }
        };
        window.addEventListener('message', event => {
            if (event.data && event.data.type === 'dialogue') {
                addDialogue(event.data.text);
            }
        });
        function addDialogue(text) {
            const div = document.createElement('div');
            div.textContent = text;
            div.className = 'transition-opacity duration-300 opacity-0';
            dialogue.appendChild(div);
            setTimeout(() => { div.classList.remove('opacity-0'); div.classList.add('opacity-100'); }, 10);
            dialogue.scrollTop = dialogue.scrollHeight;
        }
    </script>
</body>
</html>`;
}

// --- Extension Activation ---
// Ensure this is at the top level, not inside any class or function

export function activate(context: vscode.ExtensionContext) {
    // Restore session state
    agentCooperationPaused = context.globalState.get('agentCooperationPaused', false);
    agentCooperationGoal = context.globalState.get('agentCooperationGoal', undefined);
    LLM_API_URL = context.globalState.get('llmApiUrl', LLM_API_URL);
    LLM_MODEL = context.globalState.get('llmModel', LLM_MODEL);
    LLM_TEMPERATURE = context.globalState.get('llmTemp', LLM_TEMPERATURE);
    MAX_PROMPTS_PER_SESSION = context.globalState.get('maxPrompts', MAX_PROMPTS_PER_SESSION);
    CONTEXT_SOURCE = context.globalState.get('contextSource', 'editor');
    FILE_REVIEW_PATHS = context.globalState.get('fileReviewPaths', '');
    SPEC_RESOURCE_URLS = context.globalState.get('specResourceUrls', '');

    logFilePath = path.join(context.extensionPath, 'copilot_interactions.log');

    const historyProvider = new HistoryProvider();
    vscode.window.registerTreeDataProvider('copilotAutomatorHistory', historyProvider);

    const commandsProvider = new CommandsProvider(commandsJson);
    vscode.window.registerTreeDataProvider('copilotAutomatorCommands', commandsProvider);

    const modelsProvider = new LLMModelsProvider(context);
    vscode.window.registerTreeDataProvider('copilotAutomatorModels', modelsProvider);

    const provider = new AutomatorPanelProvider(context.extensionUri);
    context.subscriptions.push(vscode.window.registerWebviewViewProvider(AutomatorPanelProvider.viewType, provider));



    // Register commands
    context.subscriptions.push(
        vscode.commands.registerCommand('copilot-automator.runCommand', async (cmd: string) => {
            historyProvider.add(new HistoryItem(`Command: ${cmd}`, 'Clicked in Available Commands'));
            switch (cmd) {
                case 'start':
                    await vscode.commands.executeCommand('copilot-automator.start');
                    break;
                case 'pause':
                    await vscode.commands.executeCommand('copilot-automator.pause');
                    break;
                case 'resume':
                    await vscode.commands.executeCommand('copilot-automator.resume');
                    break;
                case 'stop':
                    await vscode.commands.executeCommand('copilot-automator.stop');
                    break;
                case 'openSettings':
                    await vscode.commands.executeCommand('copilot-automator.openSettings');
                    break;
                case 'sendPrompt':
                    const prompt = await vscode.window.showInputBox({ prompt: 'Enter prompt to send to Copilot Chat:' });
                    if (prompt) await sendPromptToChat(prompt, historyProvider);
                    break;
                case 'acceptSuggestion':
                    await acceptCopilotSuggestion();
                    break;
                case 'logInteraction':
                    const logMsg = await vscode.window.showInputBox({ prompt: 'Enter log message:' });
                    if (logMsg) {
                        logInteraction(LOG_LEVEL_INFO, 'USER_LOG', logMsg);
                        vscode.window.showInformationMessage('Log entry added.');
                    }
                    break;
                default:
                    vscode.window.showWarningMessage(`No action implemented for command: ${cmd}`);
            }
        }),
        vscode.commands.registerCommand('copilot-automator.start', async () => {
            if (agentCooperationActive) {
                vscode.window.showInformationMessage('Copilot Automator is already running.');
                return;
            }
            agentCooperationActive = true;
            agentCooperationPaused = false;
            promptCount = 0;
            const goal = await vscode.window.showInputBox({ prompt: 'What is your cooperation goal for Copilot?' });
            if (!goal) {
                vscode.window.showWarningMessage('No goal provided. Cooperation cancelled.');
                agentCooperationActive = false;
                return;
            }
            agentCooperationGoal = goal;
            await context.globalState.update('agentCooperationGoal', goal);
            await context.globalState.update('agentCooperationPaused', false);
            logInteraction(LOG_LEVEL_INFO, 'AGENT_COOPERATION_STARTED', goal);
            historyProvider.add(new HistoryItem('Cooperation started', goal));
            if (agentCooperationGoal) {
                agentCooperationLoop = setTimeout(() => agentCooperationMain(agentCooperationGoal as string, historyProvider), 0);
            }
        }),
        vscode.commands.registerCommand('copilot-automator.pause', async () => {
            if (agentCooperationActive && !agentCooperationPaused) {
                agentCooperationPaused = true;
                await context.globalState.update('agentCooperationPaused', true);
                vscode.window.showInformationMessage('Copilot Automator paused.');
                logInteraction(LOG_LEVEL_INFO, 'AGENT_COOPERATION_PAUSED', 'Paused by user.');
                historyProvider.add(new HistoryItem('Cooperation paused', 'Paused by user'));
            }
        }),
        vscode.commands.registerCommand('copilot-automator.resume', async () => {
            if (agentCooperationActive && agentCooperationPaused) {
                agentCooperationPaused = false;
                await context.globalState.update('agentCooperationPaused', false);
                vscode.window.showInformationMessage('Copilot Automator resumed.');
                logInteraction(LOG_LEVEL_INFO, 'AGENT_COOPERATION_RESUMED', 'Resumed by user.');
                historyProvider.add(new HistoryItem('Cooperation resumed', 'Resumed by user'));
                if (agentCooperationGoal) {
                    agentCooperationLoop = setTimeout(() => agentCooperationMain(agentCooperationGoal as string, historyProvider), 0);
                }
            }
        }),
        vscode.commands.registerCommand('copilot-automator.stop', () => {
            agentCooperationActive = false;
            agentCooperationPaused = false;
            agentCooperationGoal = undefined;
            context.globalState.update('agentCooperationPaused', false);
            context.globalState.update('agentCooperationGoal', undefined);
            if (agentCooperationLoop) {
                clearTimeout(agentCooperationLoop);
                agentCooperationLoop = undefined;
            }
            logInteraction(LOG_LEVEL_INFO, 'AGENT_COOPERATION_STOPPED', 'Cooperation stopped by user.');
            historyProvider.add(new HistoryItem('Cooperation stopped', 'Stopped by user'));
            vscode.window.showInformationMessage('Copilot Automator stopped.');
        }),
        vscode.commands.registerCommand('copilot-automator.openSettings', () => {
            openSettingsPanel(context);
        }),
        vscode.commands.registerCommand('copilot-automator.selectFiles', async () => {
            await flexibleFileSelection();
            if (selectedFiles.length > 0) {
                const fileNames = selectedFiles.map(f => path.basename(f)).join(', ');
                historyProvider.add(new HistoryItem('Files Selected', fileNames));
            } else {
                historyProvider.add(new HistoryItem('No Files Selected', 'File selection cancelled.'));
            }
        }),
        vscode.commands.registerCommand('copilot-automator.manageSpecResources', () => {
            openSpecResourcesPanel(context);
        }),
        vscode.commands.registerCommand('copilot-automator.createTemplateInstruction', () => {
            createTemplateInstructionFile();
        }),
        vscode.commands.registerCommand('copilot-automator.validateInstructions', () => {
            validateAllInstructionFiles();
        }),
        vscode.commands.registerCommand('copilot-automator.runInstructionFile', () => {
            runAutomationFromInstructionFile(historyProvider);
        }),
        vscode.commands.registerCommand('copilot-automator.openLogViewer', () => {
            openLogViewerPanel();
        }),
        vscode.commands.registerCommand('copilot-automator.refreshModels', () => modelsProvider.refresh()),
        vscode.commands.registerCommand('copilot-automator.selectModel', async (model: string) => {
            await modelsProvider.selectModel(model);
        })
    );

    modelsProvider.refresh();
}
// --- Extension Deactivation ---
// ...
export function deactivate() {
    agentCooperationActive = false;
    agentCooperationPaused = false;
    if (agentCooperationLoop) {
        clearTimeout(agentCooperationLoop);
        agentCooperationLoop = undefined;
    }
}